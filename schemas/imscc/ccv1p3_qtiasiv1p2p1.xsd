<?xml version="1.0" encoding="UTF-8"?>
<!--
    IMS QTI ASI v1.2.1 Schema (Common Cartridge Profile)
    Based on: http://www.imsglobal.org/profile/cc/ccv1p3/ccv1p3_qtiasiv1p2p1_v1p0.xsd

    This schema validates QTI assessment XML files for IMSCC packages.
    Namespace: http://www.imsglobal.org/xsd/ims_qtiasiv1p2

    Supported question types (cc_profile values):
    - cc.multiple_choice.v0p1
    - cc.multiple_response.v0p1
    - cc.true_false.v0p1
    - cc.fib.v0p1 (fill in blank)
    - cc.essay.v0p1
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://www.imsglobal.org/xsd/ims_qtiasiv1p2"
           targetNamespace="http://www.imsglobal.org/xsd/ims_qtiasiv1p2"
           elementFormDefault="qualified"
           version="1.2.1">

    <!-- Root Element -->
    <xs:element name="questestinterop" type="QuestestInterop.Type"/>

    <!-- QuestestInterop Type (Root Container) -->
    <xs:complexType name="QuestestInterop.Type">
        <xs:choice>
            <xs:element name="assessment" type="Assessment.Type"/>
            <xs:element name="objectbank" type="ObjectBank.Type"/>
        </xs:choice>
    </xs:complexType>

    <!-- Assessment Type -->
    <xs:complexType name="Assessment.Type">
        <xs:sequence>
            <xs:element name="qtimetadata" type="QTIMetadata.Type" minOccurs="0"/>
            <xs:element name="section" type="Section.Type" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:ID" use="required"/>
        <xs:attribute name="title" type="xs:string"/>
    </xs:complexType>

    <!-- ObjectBank Type (for question pools) -->
    <xs:complexType name="ObjectBank.Type">
        <xs:sequence>
            <xs:element name="qtimetadata" type="QTIMetadata.Type" minOccurs="0"/>
            <xs:element name="item" type="Item.Type" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:ID" use="required"/>
    </xs:complexType>

    <!-- Section Type -->
    <xs:complexType name="Section.Type">
        <xs:sequence>
            <xs:element name="qtimetadata" type="QTIMetadata.Type" minOccurs="0"/>
            <xs:element name="item" type="Item.Type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="section" type="Section.Type" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:ID" use="required"/>
        <xs:attribute name="title" type="xs:string"/>
    </xs:complexType>

    <!-- Item Type (Question) -->
    <xs:complexType name="Item.Type">
        <xs:sequence>
            <xs:element name="itemmetadata" type="ItemMetadata.Type" minOccurs="0"/>
            <xs:element name="presentation" type="Presentation.Type"/>
            <xs:element name="resprocessing" type="ResProcessing.Type" minOccurs="0"/>
            <xs:element name="itemfeedback" type="ItemFeedback.Type" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:ID" use="required"/>
        <xs:attribute name="title" type="xs:string"/>
    </xs:complexType>

    <!-- QTI Metadata Type -->
    <xs:complexType name="QTIMetadata.Type">
        <xs:sequence>
            <xs:element name="qtimetadatafield" type="QTIMetadataField.Type" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- QTI Metadata Field Type -->
    <xs:complexType name="QTIMetadataField.Type">
        <xs:sequence>
            <xs:element name="fieldlabel" type="xs:string"/>
            <xs:element name="fieldentry" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Item Metadata Type -->
    <xs:complexType name="ItemMetadata.Type">
        <xs:sequence>
            <xs:element name="qtimetadata" type="QTIMetadata.Type"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Presentation Type -->
    <xs:complexType name="Presentation.Type">
        <xs:sequence>
            <xs:element name="material" type="Material.Type" minOccurs="0"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="response_lid" type="ResponseLid.Type"/>
                <xs:element name="response_str" type="ResponseStr.Type"/>
                <xs:element name="response_num" type="ResponseNum.Type"/>
                <xs:element name="response_grp" type="ResponseGrp.Type"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <!-- Material Type -->
    <xs:complexType name="Material.Type">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="mattext" type="MatText.Type"/>
                <xs:element name="matref" type="MatRef.Type"/>
                <xs:element name="matbreak" type="xs:string"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <!-- MatText Type -->
    <xs:complexType name="MatText.Type">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="texttype" type="xs:string" default="text/plain"/>
                <xs:attribute name="charset" type="xs:string"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- MatRef Type -->
    <xs:complexType name="MatRef.Type">
        <xs:attribute name="linkrefid" type="xs:IDREF" use="required"/>
    </xs:complexType>

    <!-- Response LID Type (for choice-based responses) -->
    <xs:complexType name="ResponseLid.Type">
        <xs:sequence>
            <xs:element name="render_choice" type="RenderChoice.Type"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:ID" use="required"/>
        <xs:attribute name="rcardinality" type="Cardinality.Enum" default="Single"/>
    </xs:complexType>

    <!-- Response String Type (for text responses) -->
    <xs:complexType name="ResponseStr.Type">
        <xs:sequence>
            <xs:element name="render_fib" type="RenderFib.Type"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:string" use="required"/>
        <xs:attribute name="rcardinality" type="Cardinality.Enum" default="Single"/>
    </xs:complexType>

    <!-- Response Num Type (for numeric responses) -->
    <xs:complexType name="ResponseNum.Type">
        <xs:sequence>
            <xs:element name="render_fib" type="RenderFib.Type"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:string" use="required"/>
        <xs:attribute name="numtype" type="xs:string"/>
    </xs:complexType>

    <!-- Response Grp Type (for matching) -->
    <xs:complexType name="ResponseGrp.Type">
        <xs:sequence>
            <xs:element name="render_choice" type="RenderChoice.Type"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:string" use="required"/>
    </xs:complexType>

    <!-- Cardinality Enumeration -->
    <xs:simpleType name="Cardinality.Enum">
        <xs:restriction base="xs:token">
            <xs:enumeration value="Single"/>
            <xs:enumeration value="Multiple"/>
            <xs:enumeration value="Ordered"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- Render Choice Type -->
    <xs:complexType name="RenderChoice.Type">
        <xs:sequence>
            <xs:element name="response_label" type="ResponseLabel.Type" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="shuffle" type="xs:string"/>
    </xs:complexType>

    <!-- Render FIB Type -->
    <xs:complexType name="RenderFib.Type">
        <xs:sequence>
            <xs:element name="response_label" type="ResponseLabel.Type" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="fibtype" type="xs:string"/>
        <xs:attribute name="rows" type="xs:integer"/>
        <xs:attribute name="columns" type="xs:integer"/>
    </xs:complexType>

    <!-- Response Label Type -->
    <xs:complexType name="ResponseLabel.Type">
        <xs:sequence>
            <xs:element name="material" type="Material.Type" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="ident" type="xs:string" use="required"/>
        <xs:attribute name="rshuffle" type="xs:string"/>
    </xs:complexType>

    <!-- Response Processing Type -->
    <xs:complexType name="ResProcessing.Type">
        <xs:sequence>
            <xs:element name="outcomes" type="Outcomes.Type" minOccurs="0"/>
            <xs:element name="respcondition" type="RespCondition.Type" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Outcomes Type -->
    <xs:complexType name="Outcomes.Type">
        <xs:sequence>
            <xs:element name="decvar" type="DecVar.Type" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- DecVar Type -->
    <xs:complexType name="DecVar.Type">
        <xs:attribute name="varname" type="xs:string" default="SCORE"/>
        <xs:attribute name="vartype" type="xs:string" default="Decimal"/>
        <xs:attribute name="minvalue" type="xs:decimal"/>
        <xs:attribute name="maxvalue" type="xs:decimal"/>
    </xs:complexType>

    <!-- Response Condition Type -->
    <xs:complexType name="RespCondition.Type">
        <xs:sequence>
            <xs:element name="conditionvar" type="ConditionVar.Type"/>
            <xs:element name="setvar" type="SetVar.Type" minOccurs="0"/>
            <xs:element name="displayfeedback" type="DisplayFeedback.Type" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="continue" type="xs:string"/>
    </xs:complexType>

    <!-- Condition Var Type -->
    <xs:complexType name="ConditionVar.Type">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="varequal" type="VarEqual.Type"/>
            <xs:element name="varsubstring" type="VarSubstring.Type"/>
            <xs:element name="and" type="ConditionVar.Type"/>
            <xs:element name="or" type="ConditionVar.Type"/>
            <xs:element name="not" type="ConditionVar.Type"/>
            <xs:element name="other"/>
        </xs:choice>
    </xs:complexType>

    <!-- VarEqual Type -->
    <xs:complexType name="VarEqual.Type">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="respident" type="xs:string" use="required"/>
                <xs:attribute name="case" type="xs:string"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- VarSubstring Type -->
    <xs:complexType name="VarSubstring.Type">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="respident" type="xs:string" use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- SetVar Type -->
    <xs:complexType name="SetVar.Type">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="varname" type="xs:string" default="SCORE"/>
                <xs:attribute name="action" type="xs:string" default="Set"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- Display Feedback Type -->
    <xs:complexType name="DisplayFeedback.Type">
        <xs:attribute name="feedbacktype" type="xs:string"/>
        <xs:attribute name="linkrefid" type="xs:string" use="required"/>
    </xs:complexType>

    <!-- Item Feedback Type -->
    <xs:complexType name="ItemFeedback.Type">
        <xs:choice>
            <xs:element name="flow_mat" type="FlowMat.Type"/>
            <xs:element name="solution" type="Solution.Type"/>
        </xs:choice>
        <xs:attribute name="ident" type="xs:string" use="required"/>
    </xs:complexType>

    <!-- Flow Mat Type -->
    <xs:complexType name="FlowMat.Type">
        <xs:sequence>
            <xs:element name="material" type="Material.Type"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Solution Type -->
    <xs:complexType name="Solution.Type">
        <xs:sequence>
            <xs:element name="solutionmaterial" type="SolutionMaterial.Type"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Solution Material Type -->
    <xs:complexType name="SolutionMaterial.Type">
        <xs:sequence>
            <xs:element name="flow_mat" type="FlowMat.Type"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
